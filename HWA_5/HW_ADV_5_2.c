/*
 * Алексеев Дмитрий Александрович
 * 
 * Задача 5-2-Префикс и суфикс 
 * На стандартном потоке ввода задаются две символьные строки, разделённые символом перевода строки.
 *  Каждая из строк не превышает по длине 104. В строках не встречаются пробельные символы.
 * На стандартный поток вывода напечатайте два числа, разделённых пробелом:
 *  первое число — длина наибольшего префикса первой строки, являющегося суффиксом второй;
 *  второе число — наоборот, длина наибольшего суффикса первой строки, являющегося префиксом второй.
 *  Сравнение символов проводите с учётом регистра (т.е. символы 'a' и 'A' различны).
 * 
 * Пример №1
 * Данные на входе:
 * don't_panic 
 * nick_is_a_mastodon
 * Данные на выходе:	3 3
 * 
 * Пример №2
 * Данные на входе:
 * monty_python
 * python_has_list_comprehensions
 * Данные на выходе:	0 6
 */


#include <stdio.h>
#include <string.h>

// Функция для построения Z-функции строки
void build_z_function(char *s, int *z, int len) {
  z[0] = 0; // Z-функция для первого символа всегда равна 0
  int l = 0, r = 0; // l - начало, r - конец текущего "box"

  // Цикл по всем позициям строки
  for (int i = 1; i < len; i++) {
    // Если текущая позиция находится за пределами "box"
    if (i > r) {
      l = i; // Начало "box" - текущая позиция
      r = i; // Конец "box" - текущая позиция
      // Ищем самый длинный префикс, совпадающий с суффиксом
      while (r < len && s[r] == s[r - l]) {
        r++;
      }
      z[i] = r - l; // Записываем длину префикса
      r--; // Устанавливаем конец "box" на символ перед последним совпадающим
    } else {
      // Если текущая позиция внутри "box"
      int k = i - l; // Позиция, симметричная i относительно начала "box"
      // Если длина префикса на позиции k меньше, чем расстояние до конца "box"
      if (z[k] < r - i + 1) {
        z[i] = z[k]; // Записываем длину префикса с позиции k
      } else {
        // Если длина префикса на позиции k больше или равна расстоянию до конца "box"
        l = i; // Начало "box" - текущая позиция
        // Ищем самый длинный префикс, совпадающий с суффиксом
        while (r < len && s[r] == s[r - l]) {
          r++;
        }
        z[i] = r - l; // Записываем длину префикса
        r--; // Устанавливаем конец "box" на символ перед последним совпадающим
      }
    }
  }
}

int main() {
  char str1[105], str2[105];
  
  // Ввод строк
  fgets(str1, 105, stdin);
  fgets(str2, 105, stdin);

  // Удаление символа перевода строки из строк
  str1[strcspn(str1, "\n")] = '\0';
  str2[strcspn(str2, "\n")] = '\0';

  int len1 = strlen(str1);
  int len2 = strlen(str2);

  int max_prefix_suffix = 0; // Длина наибольшего префикса первой строки, являющегося суффиксом второй
  int max_suffix_prefix = 0; // Длина наибольшего суффикса первой строки, являющегося префиксом второй

  // Строим Z-функцию для конкатенации второй строки, символа '#' и первой строки
  char concat1[205];
  sprintf(concat1, "%s#%s", str2, str1); 
  int z1[205];
  build_z_function(concat1, z1, strlen(concat1));

  // Находим максимальное значение Z-функции для позиции начала первой строки
  for (int i = len2 + 1; i < len2 + len1 + 1; i++) {
    if (z1[i] > max_prefix_suffix) {
      max_prefix_suffix = z1[i];
    }
  }

  // Строим Z-функцию для конкатенации первой строки, символа '#' и второй строки
  char concat2[205];
  sprintf(concat2, "%s#%s", str1, str2);
  int z2[205];
  build_z_function(concat2, z2, strlen(concat2));

  // Находим максимальное значение Z-функции для позиции начала второй строки
  // (чтобы найти максимальный префикс второй строки, который является суффиксом первой)
  for (int i = len1 + 1; i < len1 + len2 + 1; i++) {
    if (z2[i] > max_suffix_prefix) {
      max_suffix_prefix = z2[i];
    }
  }

  // Вывод результатов
  printf("%d %d\n", max_prefix_suffix, max_suffix_prefix);

  return 0;
}
