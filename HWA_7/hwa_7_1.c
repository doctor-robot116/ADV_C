/*
 * Алексеев Дмитрий Александрович
 *
 * Задача 7-1-Отсортировать слова
 * Дана строка, состоящая из английских букв и пробелов.
 *  В конце строки символ точка. Все слова разделены одним пробелом.
 *  Необходимо составить из слов односвязный список и упорядочить по алфавиту.
 *  Список необходимо удалить в конце программы. Для сравнение строк можно использовать strcmp.
 *  Необходимо использовать данную структуры организации списка.
 * struct list {
 * char word[20];
 * struct list *next;
 * }
 *
 * Необходимо реализовать односвязный список и обслуживающие его функции.
 *  add_to_list swap_elements print_list delete_list
 *
 * Формат ввода:
 * Строка из английских символов 'a'-'z' и пробелов.
 * В конце строки символ '.'.
 *  Длинна строки не более 1000 символов.
 *
 * Формат вывода:
 * Упорядоченные по алфавиту слова.
 *
 * Пример №1
 * Данные на входе:		efg abcd zzz.
 * Данные на выходе:	abcd efg zzz
 *
 * Пример №2
 * Данные на входе:		fffff kkkkkk a.
 * Данные на выходе:	a fffff kkkkkk
 *
 */


#include <stdio.h>
#include <string.h>
#include <stdlib.h>

struct list
{
    char word[20];
    struct list *next;
};
// Функция для вставки слова в отсортированный список
struct list *insert_sorted(struct list *head, char *word)
{
    struct list *new_node = (struct list *)malloc(sizeof(struct list)); // Выделение памяти для нового узла
    if (new_node == NULL) {
        printf("Ошибка выделения памяти!\n");
        exit(1);
    }
    strcpy(new_node->word, word);
    if (head == NULL || strcmp(word, head->word) < 0)   // Проверка, пуст ли список или новое слово меньше, чем первое слово в списке
    { 
        new_node->next = head; // Установка указателя на следующий элемент нового узла на текущую голову списка
        return new_node; // Возвращение указателя на новый узел (новая голова списка)
    }
    struct list *current = head; // Инициализация указателя на текущий узел
    while (current->next != NULL && strcmp(word, current->next->word) >= 0)   // Проход по списку до тех пор, пока не будет найден узел, в который нужно вставить новое слово
    { 
        current = current->next; // Переход к следующему узлу
    }
    new_node->next = current->next; // Установка указателя на следующий элемент нового узла на следующий элемент текущего узла
    current->next = new_node; // Установка указателя на следующий элемент текущего узла на новый узел
    return head; // Возвращение указателя на голову списка
}

// Функция для печати списка
void print_list(struct list *head)
{
    while (head != NULL) {
        printf("%s", head->word);
        head = head->next; // Переход к следующему узлу
        if (head != NULL) { // Проверка, есть ли следующий узел
            printf(" ");
        }
    }
}

// Функция для удаления списка
void delete_list(struct list **head)
{
    struct list *current = *head; // Инициализация указателя на текущий узел
    while (current != NULL) { // Проход по списку
        struct list *next = current->next; // Сохранение указателя на следующий узел
        free(current); // Освобождение памяти, выделенной для текущего узла
        current = next; // Переход к следующему узлу
    }
    *head = NULL; // Установка указателя на голову списка в NULL
}

int main()
{
    char str[1000]; // Массив символов для хранения введенной строки
    struct list *head = NULL; // Инициализация указателя на голову списка
    fgets(str, 1000, stdin); // Ввод строки с клавиатуры
    str[strcspn(str, ".")] = 0; // Удаление точки с конца строки
    char *word = strtok(str, " "); // Разделение строки на словам с помощью пробела как разделителя
    while (word != NULL)   // Проход по словам
    { 
        head = insert_sorted(head, word); // Вставка слова в отсортированный список
        word = strtok(NULL, " "); // Переход к следующему токену
    }
    print_list(head);
    delete_list(&head);
    return 0;
}
